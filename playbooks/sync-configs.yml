- name: Synchroniser les fichiers de configuration vers ce serveur de monitoring
  hosts: all
  gather_facts: yes

  vars:
    dest_base: /opt/monitoring/homelab-config/config

    # Chemins de configuration pour chaque service
    services:
      traefik: /opt/traefik
      homarr: /opt/homarr
      adguard: /opt/adguardhome/conf
      immich: /opt/immich/docker
      vaultwarden: /opt/vaultwarden
      jellyseer: /opt/jellyseer
      mealie: /opt/mealie
      grocy: /opt/grocy
      arrstack: /opt/appdata
      paperless: /mnt/paperless_data
      prometheus: /opt/monitoring/prometheus
      mealie_grocy: /opt/mealie_grocy

    # Patterns de fichiers à récupérer
    file_patterns:
      - "*.yml"
      - "*.yaml"
      - "*.toml"
      - "*.json"
      - ".env"
      - "*.ini"
      - "*.sh"
      - "docker-compose.yml"
      - "docker-compose.yaml"

  pre_tasks:
    - name: Marquer les hôtes à ignorer si pas dans services
      set_fact:
        skip_host: true
      when: services[inventory_hostname] is not defined

  tasks:
    - name: Définir les variables du service
      set_fact:
        service_name: "{{ inventory_hostname }}"
        config_path: "{{ services[inventory_hostname] }}"
      when: not skip_host | default(false)

    - name: Vérifier que le dossier source existe
      stat:
        path: "{{ config_path }}"
      register: source_dir
      when: not skip_host | default(false)

    - name: Afficher le chemin de configuration
      debug:
        msg: "Service {{ service_name }} - Chemin: {{ config_path }} - Existe: {{ source_dir.stat.exists }}"
      when: not skip_host | default(false)

    # Copier les fichiers de config dans un répertoire temporaire
    - name: Copier les fichiers de config dans un répertoire temporaire
      become: true
      shell: |
        set -e
        export_dir="/home/ansible/backup_{{ service_name }}"
        echo "[DEBUG] Création du dossier $export_dir"
        mkdir -p "$export_dir"
        echo "[DEBUG] Dossier de config : {{ config_path }}"
        echo "[DEBUG] Fichiers matchés : {{ file_patterns | join(', ') }}"

        echo "[DEBUG] Lancement de la copie..."
        find {{ config_path }} -type f \( {% for ext in file_patterns %} -iname '{{ ext }}'{% if not loop.last %} -o {% endif %}{% endfor %} \) \
          -not -path "*/\.*" \
          -not -path "*/data/*" \
          -not -path "*/node_modules/*" \
          -not -path "*/vendor/*" \
          -not -path "*/.git/*" \
          -not -path "*/build/*" \
          -not -path "*/dist/*" \
          -not -path "*/target/*" \
          -not -path "*/@*" \
          -exec cp --parents {} "$export_dir" \;

        echo "[DEBUG] Correction des permissions"
        chown -R ansible:ansible "$export_dir"
        echo "[DEBUG] Terminé copie vers $export_dir"
      register: backup_cp_result
      when:
        - not skip_host | default(false)
        - source_dir.stat.exists

    # Vérifier que le dossier backup a été créé et contient des fichiers
    - name: Vérifier la présence du répertoire backup
      become: true
      stat:
        path: "/home/ansible/backup_{{ service_name }}"
      register: backup_folder_check
      when: not skip_host | default(false)

    - name: Lister le contenu du dossier backup
      become: true
      shell: |
        export_dir="/home/ansible/backup_{{ service_name }}"
        if [ -d "$export_dir" ]; then
          echo "Contenu du dossier $export_dir:"
          find "$export_dir" -type f | head -20
          echo "Nombre total de fichiers: $(find "$export_dir" -type f | wc -l)"
        else
          echo "Dossier $export_dir n'existe pas"
        fi
      register: backup_content
      when: not skip_host | default(false)

    - name: Afficher le contenu du backup
      debug:
        var: backup_content.stdout_lines
      when: backup_content is defined

    # Créer une archive avec tar
    - name: Créer une archive avec tar
      shell: |
        export_dir="/home/ansible/backup_{{ service_name }}"
        tmp_archive="/tmp/{{ service_name }}.tar.gz"
        if [ -d "$export_dir" ] && [ "$(ls -A $export_dir)" ]; then
          tar -czf "$tmp_archive" -C "$export_dir" .
          echo "Archive créée: $tmp_archive"
          ls -la "$tmp_archive"
        else
          echo "Dossier vide ou inexistant: $export_dir"
        fi
      register: archive_result
      when: not skip_host | default(false)

    # Vérifier que l'archive a bien été créée
    - name: Vérifier que l'archive a bien été créée
      stat:
        path: "/tmp/{{ service_name }}.tar.gz"
      register: archive_file
      when: not skip_host | default(false)

    # Créer le dossier final sur le serveur de monitoring
    - name: Créer le dossier final sur le serveur de monitoring
      delegate_to: localhost
      become: true
      file:
        path: "{{ dest_base }}/{{ service_name }}"
        state: directory
        mode: '0755'
      when:
        - not skip_host | default(false)
        - archive_file.stat.exists

    # Copier l'archive vers le serveur de monitoring
    - name: Copier l'archive vers le serveur de monitoring
      fetch:
        src: "/tmp/{{ service_name }}.tar.gz"
        dest: "{{ dest_base }}/{{ service_name }}/"
        flat: yes
      when:
        - not skip_host | default(false)
        - archive_file.stat.exists

    # Extraire l'archive sur le serveur de monitoring
    - name: Extraire l'archive sur le serveur de monitoring
      delegate_to: localhost
      become: true
      unarchive:
        src: "{{ dest_base }}/{{ service_name }}/{{ service_name }}.tar.gz"
        dest: "{{ dest_base }}/{{ service_name }}"
        remote_src: true
      when:
        - not skip_host | default(false)
        - archive_file.stat.exists

    # Réorganiser les fichiers pour qu'ils soient à la racine
    - name: Réorganiser les fichiers à la racine du dossier
      delegate_to: localhost
      become: true
      shell: |
        cd "{{ dest_base }}/{{ service_name }}"
        echo "Réorganisation des fichiers..."
        
        # Supprimer seulement le premier niveau de dossiers (opt, mnt, etc.)
        for dir in */; do
          if [ -d "$dir" ]; then
            echo "Déplacement du contenu de $dir vers la racine"
            # Déplacer tout le contenu du dossier vers la racine
            mv "$dir"* . 2>/dev/null || true
            # Supprimer le dossier vide
            rmdir "$dir" 2>/dev/null || true
          fi
        done
        
        # Supprimer les dossiers vides restants
        find . -type d -empty -delete 2>/dev/null || true
        
        echo "Réorganisation terminée"
      when:
        - not skip_host | default(false)
        - archive_file.stat.exists

    # Nettoyer les fichiers temporaires sur les hôtes distants
    - name: Nettoyer les fichiers temporaires sur les hôtes distants
      become: true
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - "/tmp/{{ service_name }}.tar.gz"
        - "/home/ansible/backup_{{ service_name }}"
      when: not skip_host | default(false)

    # Nettoyer l'archive temporaire sur le serveur de monitoring
    - name: Nettoyer l'archive temporaire sur le serveur de monitoring
      delegate_to: localhost
      become: true
      file:
        path: "{{ dest_base }}/{{ service_name }}/{{ service_name }}.tar.gz"
        state: absent
      when:
        - not skip_host | default(false)
        - archive_file.stat.exists

  # Tâches Git à exécuter après la synchronisation
  post_tasks:
    - name: Vérifier si des fichiers ont été modifiés
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git status --porcelain
      register: git_status
      run_once: true

    - name: Afficher le statut Git
      debug:
        var: git_status.stdout_lines
      when: git_status.stdout_lines | length > 0

    - name: Ajouter tous les fichiers modifiés au Git
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git add .
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Créer le message de commit avec la date
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        echo "backup-$(date '+%Y-%m-%d %H:%M:%S')"
      register: commit_message
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Commiter les changements
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git commit -am "{{ commit_message.stdout }}"
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Vérifier si la branche backup existe
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git branch -r | grep -q "origin/backup" || git checkout -b backup
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Basculer sur la branche backup
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git checkout backup
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Pousser vers origin backup
      delegate_to: localhost
      become: true
      shell: |
        cd /opt/monitoring/homelab-config
        git push origin backup
      when: git_status.stdout_lines | length > 0
      run_once: true

    - name: Afficher le message de succès
      debug:
        msg: "Synchronisation terminée et changements poussés vers Git"
      when: git_status.stdout_lines | length > 0
      run_once: true
